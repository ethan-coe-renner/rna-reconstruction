# RNA reconstruction
# Ethan Coe-Renner

from collections import defaultdict

# frag is a fragment, search is a list of the characters to break at, returns list of fragments
def break_frag(frag, search):
    fragments = [""]
    c = 0
    for singleteton in frag:
        fragments[c] += singleteton
        if singleteton in search:
            c += 1
            fragments.insert(c, "")
    if fragments[-1] == "":
        return fragments[:-1]

    return fragments


# takes list of fragments and breaks each by enzyme (a list of singletons to break at), returning a list of fragments
def break_frags(frags, enzyme):
    total = []
    for frag in frags:
        total += break_frag(frag, enzyme)
    return total


#takes the cu digest and g digest, returns the one or maybe two abnormal fragments
def find_abnormals(cu_frags, g_frags):
    abnormals = []
    for frag in cu_frags:
        if frag[-1] in ['g', 'a']:
            abnormals.append(frag)

    for frag in g_frags:
        if frag[-1] in ['c', 'u', 'a']:
            abnormals.append(frag)

    return abnormals


# return except of two lists
def exceptList(lst1, lst2):
    for i in lst2:
        for ii in lst1:
            if i == ii:
                lst1.remove(ii)
                break
    return lst1


# return any mid extended bases from a fragment, if it exists
def get_midextended_base(fragment, enzyme):
    bases = break_frag(fragment, enzyme)
    if len(bases) < 3:
        return None
    return bases[1:-1]


# return extended bases from digests
def find_mid_extended_bases(cu_digest, g_digest):
    extended_bases = []
    for frag in cu_digest:
        meb = get_midextended_base(frag, ['g'])
        if meb:
            extended_bases += meb

    for frag in g_digest:
        meb = get_midextended_base(frag, ['c', 'u'])
        if meb:
            extended_bases += meb

    return extended_bases


# get singleton if it is a singleton
def is_singleton(fragment, enzyme):
    bases = break_frag(fragment, enzyme)
    if len(bases) == 1:
        return bases[0]
    return None


# given a cu and g digest, find the singletons in the digests
def get_singletons(cu_digest, g_digest):
    singletons = []

    for frag in cu_digest:
        singleton = is_singleton(frag, ['g'])
        if singleton:
            singletons.append(singleton)

    for frag in g_digest:
        singleton = is_singleton(frag, ['c', 'u'])
        if singleton:
            singletons.append(singleton)

    return singletons


# start_and_end is a list of two bases, one is the start
def get_end(start_and_end, abnormals):
    end = None
    for base in start_and_end:
        for abnormal in abnormals:
            if base in abnormal:
                end = abnormal
                break
        if end:
            break
    return end


# given two digests, return the start and the end as a tuple
def get_start_and_end(uc_digest, g_digest):
    singletons = get_singletons(uc_digest, g_digest)

    midextended_bases = find_mid_extended_bases(uc_digest, g_digest)

    print("singletons: ", singletons)
    print("midextended_bases: ", midextended_bases)

    start_and_end = exceptList(singletons, midextended_bases)
    print("start_and_end:", start_and_end)

    abnormals = find_abnormals(uc_digest, g_digest)

    print("abnormals: ", abnormals)

    end = get_end(start_and_end, abnormals)
    print("end: ", end)
    start = start_and_end[0] if len(
        start_and_end) < 2 or end in start_and_end[1] else start_and_end[1]
    print("start: ", start)

    return (start, end)


# get vertices other than start and end
def get_interior_vertices(uc_digest, g_digest):

    vertices = []

    for frag in uc_digest:
        bases = break_frag(frag, ['g'])
        if len(bases) >= 3:
            vertices.append(bases[0])
            vertices.append(bases[-1])

    for frag in g_digest:
        bases = break_frag(frag, ['u', 'c'])
        if len(bases) >= 3:
            vertices.append(bases[0])
            vertices.append(bases[-1])

    return list(set(vertices))


# add the end vertice to the end of the vertices list, moving it to the end if it already exists in vertices
def add_end(vertices, end):
    for i in vertices:
        if i in end:
            vertices.remove(i)
            vertices.append(i)
            return

    vertices.append(end)


# get the full list of vertices, with the *, start at the start and end at the end
def get_vertices(uc_digest, g_digest):
    vertices = get_interior_vertices(uc_digest, g_digest)

    start, end = get_start_and_end(uc_digest, g_digest)

    vertices.insert(0, start)
    vertices.insert(0, "*")

    add_end(vertices, end)
    return vertices


# get the value for the edge between two vertices generated by a given fragment
def get_edge(fragment, enzyme):
    bases = break_frag(fragment, enzyme)
    if len(bases) == 2:
        return (bases[0], bases[1])
    elif len(bases) >= 3:
        return (bases[0], "".join(bases[1:-1]), bases[-1])  # (v1, edge, v2)
    else:
        return None


class Graph:

    def __init__(self, vertices):
        print("vertices:",vertices)
        self.vertices = vertices
        self.V = len(vertices)  #No. of vertices
        self.graph = {} # default dictionary to store graph

    def create_graph(self, uc_digest, g_digest):
        self.add_edge(0, 1, "")  # add start edge

        for frag in uc_digest:
            edge = get_edge(frag, ['g'])
            if not edge:
                continue
            if len(edge) == 2:
                self.add_edge(self.vertices.index(edge[0]),
                              self.vertices.index(edge[1]), "")
            elif len(edge) == 3:
                self.add_edge(self.vertices.index(edge[0]),
                              self.vertices.index(edge[2]), edge[1])

        for frag in g_digest:
            edge = get_edge(frag, ['u', 'c'])
            if not edge:
                continue
            if len(edge) == 2:
                self.add_edge(self.vertices.index(edge[0]),
                              self.vertices.index(edge[1]), "")
            elif len(edge) == 3:
                self.add_edge(self.vertices.index(edge[0]),
                              self.vertices.index(edge[2]), edge[1])

        self.add_edge(self.V - 1, 0, "")  # add ending edge

    # function to add an edge to graph
    def add_edge(self, u, v, base):
        if u in self.graph:
            self.graph[u].append((v, base))
        else:
            self.graph[u] = [(v,base)]

    # This function removes edge u-v from graph
    def remove_edge(self, u, v):
        for index, key in enumerate(self.graph[u]):
            if key[0] == v:
                x = self.graph[u][index][1]
                self.graph[u].pop(index)
                return x
        print("Error: returning none from rmv")
        return ""

    def DFSCount(self, v, visited):
        count = 1
        visited[v] = True
        for i in self.graph[v]:
            if visited[i[0]] == False:
                count = count + self.DFSCount(i[0], visited)
        return count

    # The function to check if edge u-v can be considered as next edge in
    # Euler Tour
    def is_valid_next_edge(self, u, v, current:bool):
        if len(self.graph[u]) == 1:
            return True
        else:
            visited = [False] * (self.V)
            count1 = self.DFSCount(u if current else v, visited)
            # print(visited)

            base = self.remove_edge(u, v)
            # print('removing edge in valid check',self.graph)
            visited = [False] * (self.V)
            count2 = self.DFSCount(u if current else v, visited)
            # print(visited)

            self.add_edge(u, v, base)
            # print('adding edge in valid check',self.graph)
            # print("count1:", count1, "count2:", count2)

            return False if count1 > count2 else True

    # Print Euler tour starting from vertex u
    def print_euler_util(self, u):
        global euler_cycle
        possibles = []
        # check if valid edge based on current dfs
        for v in self.graph[u]:
            # print("checking edge", u, "to", v[0])
            if self.is_valid_next_edge(u, v[0], current=True):
                possibles.append(v)
                # print("valid edge", u, "to", v[0])
        if possibles:
            euler_cycle += self.vertices[u] + possibles[0][1]
            self.remove_edge(u, possibles[0][0])
            self.print_euler_util(possibles[0][0])
            return

        # check if valid edge based on next dfs
        for v in self.graph[u]:
            # print("checking edge", u, "to", v[0])
            if self.is_valid_next_edge(u, v[0], current=False):
                possibles.append(v)
                # print("valid edge", u, "to", v[0])
        if possibles:
            euler_cycle += self.vertices[u] + possibles[0][1]
            self.remove_edge(u, possibles[0][0])
            self.print_euler_util(possibles[0][0])
            return

    def left(self):
        for (i,val) in self.graph.items():
            if val:
                return i
        return None

    def print_euler_cycle(self):
        #Find a vertex with odd degree
        u = 0
        for i in range(self.V):
            if len(self.graph[i]) % 2 != 0:
                u = i
                break
        # Print tour starting from odd vertex
        global euler_cycle
        euler_cycle = ""
        print("\n")
        self.print_euler_util(u)
        left = self.left() # whats left in the graph
        while left:
            self.print_euler_util(left)
            left = self.left()
        print("reconstruction:", euler_cycle + "*")


def main():
    print("RNA Reconstruction")
    response = input("Would you like to see an example (y/n)? ")
    if response != 'n':
        example()
        return
    print("Enter uc fragments, just enter <return> to finish")
    uc_digest = []
    fragment = input("fragment: ")
    while fragment != "":
        uc_digest.append(fragment)
        print("fragments so far in uc_digest: ", uc_digest)
        fragment = input("fragment: ")

    print("Enter g fragments, just enter <return> to finish")
    g_digest = []
    fragment = input("fragment: ")
    while fragment != "":
        g_digest.append(fragment)
        print("fragments so far in g_digest: ", g_digest)
        fragment = input("fragment: ")

    v = get_vertices(uc_digest, g_digest)
    g = Graph(v)
    g.create_graph(uc_digest, g_digest)

    print("Reconstruction: ")
    g.print_euler_cycle()


def example():
    # Lecture Mar 21
    # g_digest = ["uaccug", "cg", "g", "g", "g"]
    # uc_digest = ["u", "ac", "c", "u", "gc","gggg"]
    
    choice = int(input("Choose from HW 7 prob (1) or problem (2): "))
    print("\n------------------\n")
    if choice == 1:
        print("Example from HW 7 Problem 1:")
        g_digest = ["ag", "aag", "ucucag"]
        uc_digest = ["c", "c", "u", "aagu", "agag"]
    elif choice == 2:
        print("Example from HW 7 Problem 2:")
        uc_digest = ['c', 'c', 'agu', 'gagu', 'ggau', 'agu']
        g_digest = ['g', 'u', 'ag', 'ag', 'aug', 'uag', 'uccg']
    else:
        print("Invalid choice")
        return

    print("UC-Digest:", uc_digest)
    print("G-Digest:", g_digest)

    v = get_vertices(uc_digest, g_digest)
    g = Graph(v)
    g.create_graph(uc_digest, g_digest)
    print("Graph: ", g.graph)

    g.print_euler_cycle()


main()
